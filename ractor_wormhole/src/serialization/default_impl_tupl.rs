// note: this was all generated by Claude, would be great to use a macro instead

use ractor::async_trait;

use super::{
    ActorSerializationContext, ContextSerializable, SerializationResult,
    util::{require_buffer_size, require_min_buffer_size},
};

// 1-tuple
#[async_trait]
impl<T0> ContextSerializable for (T0,)
where
    T0: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem_bytes = self.0.serialize(ctx).await?;
        let elem_len = elem_bytes.len() as u64;
        buffer.extend_from_slice(&elem_len.to_le_bytes());
        buffer.extend_from_slice(&elem_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem_len]).await?;
        offset += elem_len;

        require_buffer_size(data, offset)?;
        Ok((elem0,))
    }
}

// 2-tuple
#[async_trait]
impl<T0, T1> ContextSerializable for (T0, T1)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1))
    }
}

// 3-tuple
#[async_trait]
impl<T0, T1, T2> ContextSerializable for (T0, T1, T2)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2))
    }
}

// 4-tuple
#[async_trait]
impl<T0, T1, T2, T3> ContextSerializable for (T0, T1, T2, T3)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3))
    }
}

// 5-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4> ContextSerializable for (T0, T1, T2, T3, T4)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
    T4: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.serialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::deserialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3, elem4))
    }
}

// 6-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5> ContextSerializable for (T0, T1, T2, T3, T4, T5)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
    T4: ContextSerializable + Send + Sync + 'static,
    T5: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.serialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.serialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::deserialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::deserialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3, elem4, elem5))
    }
}

// 7-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6> ContextSerializable for (T0, T1, T2, T3, T4, T5, T6)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
    T4: ContextSerializable + Send + Sync + 'static,
    T5: ContextSerializable + Send + Sync + 'static,
    T6: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.serialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.serialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.serialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        // Deserialize element 0
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        // Elements 1-6 follow the same pattern
        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::deserialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::deserialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::deserialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3, elem4, elem5, elem6))
    }
}

// 8-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7> ContextSerializable for (T0, T1, T2, T3, T4, T5, T6, T7)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
    T4: ContextSerializable + Send + Sync + 'static,
    T5: ContextSerializable + Send + Sync + 'static,
    T6: ContextSerializable + Send + Sync + 'static,
    T7: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.serialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.serialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.serialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.serialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::deserialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::deserialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::deserialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::deserialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7))
    }
}

// 9-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> ContextSerializable
    for (T0, T1, T2, T3, T4, T5, T6, T7, T8)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
    T4: ContextSerializable + Send + Sync + 'static,
    T5: ContextSerializable + Send + Sync + 'static,
    T6: ContextSerializable + Send + Sync + 'static,
    T7: ContextSerializable + Send + Sync + 'static,
    T8: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.serialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.serialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.serialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.serialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        let elem8_bytes = self.8.serialize(ctx).await?;
        let elem8_len = elem8_bytes.len() as u64;
        buffer.extend_from_slice(&elem8_len.to_le_bytes());
        buffer.extend_from_slice(&elem8_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        // Elements 0-8
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::deserialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::deserialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::deserialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::deserialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem8_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem8_len)?;
        let elem8 = T8::deserialize(ctx, &data[offset..offset + elem8_len]).await?;
        offset += elem8_len;

        require_buffer_size(data, offset)?;
        Ok((
            elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7, elem8,
        ))
    }
}

// 10-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ContextSerializable
    for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
    T4: ContextSerializable + Send + Sync + 'static,
    T5: ContextSerializable + Send + Sync + 'static,
    T6: ContextSerializable + Send + Sync + 'static,
    T7: ContextSerializable + Send + Sync + 'static,
    T8: ContextSerializable + Send + Sync + 'static,
    T9: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        // Elements 0-9
        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.serialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.serialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.serialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.serialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        let elem8_bytes = self.8.serialize(ctx).await?;
        let elem8_len = elem8_bytes.len() as u64;
        buffer.extend_from_slice(&elem8_len.to_le_bytes());
        buffer.extend_from_slice(&elem8_bytes);

        let elem9_bytes = self.9.serialize(ctx).await?;
        let elem9_len = elem9_bytes.len() as u64;
        buffer.extend_from_slice(&elem9_len.to_le_bytes());
        buffer.extend_from_slice(&elem9_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        // Deserialize elements 0-9
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::deserialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::deserialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::deserialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::deserialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem8_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem8_len)?;
        let elem8 = T8::deserialize(ctx, &data[offset..offset + elem8_len]).await?;
        offset += elem8_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem9_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem9_len)?;
        let elem9 = T9::deserialize(ctx, &data[offset..offset + elem9_len]).await?;
        offset += elem9_len;

        require_buffer_size(data, offset)?;
        Ok((
            elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7, elem8, elem9,
        ))
    }
}

// 11-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ContextSerializable
    for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
    T4: ContextSerializable + Send + Sync + 'static,
    T5: ContextSerializable + Send + Sync + 'static,
    T6: ContextSerializable + Send + Sync + 'static,
    T7: ContextSerializable + Send + Sync + 'static,
    T8: ContextSerializable + Send + Sync + 'static,
    T9: ContextSerializable + Send + Sync + 'static,
    T10: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        // Elements 0-10
        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.serialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.serialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.serialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.serialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        let elem8_bytes = self.8.serialize(ctx).await?;
        let elem8_len = elem8_bytes.len() as u64;
        buffer.extend_from_slice(&elem8_len.to_le_bytes());
        buffer.extend_from_slice(&elem8_bytes);

        let elem9_bytes = self.9.serialize(ctx).await?;
        let elem9_len = elem9_bytes.len() as u64;
        buffer.extend_from_slice(&elem9_len.to_le_bytes());
        buffer.extend_from_slice(&elem9_bytes);

        let elem10_bytes = self.10.serialize(ctx).await?;
        let elem10_len = elem10_bytes.len() as u64;
        buffer.extend_from_slice(&elem10_len.to_le_bytes());
        buffer.extend_from_slice(&elem10_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        // Deserialize elements 0-10
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::deserialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::deserialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::deserialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::deserialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem8_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem8_len)?;
        let elem8 = T8::deserialize(ctx, &data[offset..offset + elem8_len]).await?;
        offset += elem8_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem9_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem9_len)?;
        let elem9 = T9::deserialize(ctx, &data[offset..offset + elem9_len]).await?;
        offset += elem9_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem10_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem10_len)?;
        let elem10 = T10::deserialize(ctx, &data[offset..offset + elem10_len]).await?;
        offset += elem10_len;

        require_buffer_size(data, offset)?;
        Ok((
            elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7, elem8, elem9, elem10,
        ))
    }
}

// 12-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ContextSerializable
    for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
where
    T0: ContextSerializable + Send + Sync + 'static,
    T1: ContextSerializable + Send + Sync + 'static,
    T2: ContextSerializable + Send + Sync + 'static,
    T3: ContextSerializable + Send + Sync + 'static,
    T4: ContextSerializable + Send + Sync + 'static,
    T5: ContextSerializable + Send + Sync + 'static,
    T6: ContextSerializable + Send + Sync + 'static,
    T7: ContextSerializable + Send + Sync + 'static,
    T8: ContextSerializable + Send + Sync + 'static,
    T9: ContextSerializable + Send + Sync + 'static,
    T10: ContextSerializable + Send + Sync + 'static,
    T11: ContextSerializable + Send + Sync + 'static,
{
    async fn serialize(self, ctx: &ActorSerializationContext) -> SerializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        // Elements 0-11
        let elem0_bytes = self.0.serialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.serialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.serialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.serialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.serialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.serialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.serialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.serialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        let elem8_bytes = self.8.serialize(ctx).await?;
        let elem8_len = elem8_bytes.len() as u64;
        buffer.extend_from_slice(&elem8_len.to_le_bytes());
        buffer.extend_from_slice(&elem8_bytes);

        let elem9_bytes = self.9.serialize(ctx).await?;
        let elem9_len = elem9_bytes.len() as u64;
        buffer.extend_from_slice(&elem9_len.to_le_bytes());
        buffer.extend_from_slice(&elem9_bytes);

        let elem10_bytes = self.10.serialize(ctx).await?;
        let elem10_len = elem10_bytes.len() as u64;
        buffer.extend_from_slice(&elem10_len.to_le_bytes());
        buffer.extend_from_slice(&elem10_bytes);

        let elem11_bytes = self.11.serialize(ctx).await?;
        let elem11_len = elem11_bytes.len() as u64;
        buffer.extend_from_slice(&elem11_len.to_le_bytes());
        buffer.extend_from_slice(&elem11_bytes);

        Ok(buffer)
    }

    async fn deserialize(
        ctx: &ActorSerializationContext,
        data: &[u8],
    ) -> SerializationResult<Self> {
        let mut offset = 0;

        // Deserialize elements 0-11
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::deserialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::deserialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::deserialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::deserialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::deserialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::deserialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::deserialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::deserialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem8_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem8_len)?;
        let elem8 = T8::deserialize(ctx, &data[offset..offset + elem8_len]).await?;
        offset += elem8_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem9_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem9_len)?;
        let elem9 = T9::deserialize(ctx, &data[offset..offset + elem9_len]).await?;
        offset += elem9_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem10_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem10_len)?;
        let elem10 = T10::deserialize(ctx, &data[offset..offset + elem10_len]).await?;
        offset += elem10_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem11_len = u64::from_le_bytes(data[offset..offset + 8].try_into()?) as usize;
        offset += 8;
        require_min_buffer_size(data, offset + elem11_len)?;
        let elem11 = T11::deserialize(ctx, &data[offset..offset + elem11_len]).await?;
        offset += elem11_len;

        require_buffer_size(data, offset)?;
        Ok((
            elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7, elem8, elem9, elem10, elem11,
        ))
    }
}

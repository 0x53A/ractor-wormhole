// note: this was all generated by Claude, would be great to use a macro instead

use async_trait::async_trait;

use super::{
    ContextTransmaterializable, TransmaterializationContext, TransmaterializationResult,
    util::{require_buffer_size, require_min_buffer_size, usize_from_u64_le_bytes},
};

// 1-tuple
#[async_trait]
impl<T0> ContextTransmaterializable for (T0,)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem_bytes = self.0.immaterialize(ctx).await?;
        let elem_len = elem_bytes.len() as u64;
        buffer.extend_from_slice(&elem_len.to_le_bytes());
        buffer.extend_from_slice(&elem_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem_len]).await?;
        offset += elem_len;

        require_buffer_size(data, offset)?;
        Ok((elem0,))
    }
}

// 2-tuple
#[async_trait]
impl<T0, T1> ContextTransmaterializable for (T0, T1)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1))
    }
}

// 3-tuple
#[async_trait]
impl<T0, T1, T2> ContextTransmaterializable for (T0, T1, T2)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2))
    }
}

// 4-tuple
#[async_trait]
impl<T0, T1, T2, T3> ContextTransmaterializable for (T0, T1, T2, T3)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3))
    }
}

// 5-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4> ContextTransmaterializable for (T0, T1, T2, T3, T4)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
    T4: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.immaterialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::rematerialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3, elem4))
    }
}

// 6-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5> ContextTransmaterializable for (T0, T1, T2, T3, T4, T5)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
    T4: ContextTransmaterializable + Send + Sync + 'static,
    T5: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.immaterialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.immaterialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::rematerialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::rematerialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3, elem4, elem5))
    }
}

// 7-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6> ContextTransmaterializable for (T0, T1, T2, T3, T4, T5, T6)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
    T4: ContextTransmaterializable + Send + Sync + 'static,
    T5: ContextTransmaterializable + Send + Sync + 'static,
    T6: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.immaterialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.immaterialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.immaterialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        // Deserialize element 0
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        // Elements 1-6 follow the same pattern
        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::rematerialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::rematerialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::rematerialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3, elem4, elem5, elem6))
    }
}

// 8-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7> ContextTransmaterializable for (T0, T1, T2, T3, T4, T5, T6, T7)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
    T4: ContextTransmaterializable + Send + Sync + 'static,
    T5: ContextTransmaterializable + Send + Sync + 'static,
    T6: ContextTransmaterializable + Send + Sync + 'static,
    T7: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.immaterialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.immaterialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.immaterialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.immaterialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::rematerialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::rematerialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::rematerialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::rematerialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_buffer_size(data, offset)?;
        Ok((elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7))
    }
}

// 9-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> ContextTransmaterializable
    for (T0, T1, T2, T3, T4, T5, T6, T7, T8)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
    T4: ContextTransmaterializable + Send + Sync + 'static,
    T5: ContextTransmaterializable + Send + Sync + 'static,
    T6: ContextTransmaterializable + Send + Sync + 'static,
    T7: ContextTransmaterializable + Send + Sync + 'static,
    T8: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.immaterialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.immaterialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.immaterialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.immaterialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        let elem8_bytes = self.8.immaterialize(ctx).await?;
        let elem8_len = elem8_bytes.len() as u64;
        buffer.extend_from_slice(&elem8_len.to_le_bytes());
        buffer.extend_from_slice(&elem8_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        // Elements 0-8
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::rematerialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::rematerialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::rematerialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::rematerialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem8_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem8_len)?;
        let elem8 = T8::rematerialize(ctx, &data[offset..offset + elem8_len]).await?;
        offset += elem8_len;

        require_buffer_size(data, offset)?;
        Ok((
            elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7, elem8,
        ))
    }
}

// 10-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ContextTransmaterializable
    for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
    T4: ContextTransmaterializable + Send + Sync + 'static,
    T5: ContextTransmaterializable + Send + Sync + 'static,
    T6: ContextTransmaterializable + Send + Sync + 'static,
    T7: ContextTransmaterializable + Send + Sync + 'static,
    T8: ContextTransmaterializable + Send + Sync + 'static,
    T9: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        // Elements 0-9
        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.immaterialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.immaterialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.immaterialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.immaterialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        let elem8_bytes = self.8.immaterialize(ctx).await?;
        let elem8_len = elem8_bytes.len() as u64;
        buffer.extend_from_slice(&elem8_len.to_le_bytes());
        buffer.extend_from_slice(&elem8_bytes);

        let elem9_bytes = self.9.immaterialize(ctx).await?;
        let elem9_len = elem9_bytes.len() as u64;
        buffer.extend_from_slice(&elem9_len.to_le_bytes());
        buffer.extend_from_slice(&elem9_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        // Deserialize elements 0-9
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::rematerialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::rematerialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::rematerialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::rematerialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem8_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem8_len)?;
        let elem8 = T8::rematerialize(ctx, &data[offset..offset + elem8_len]).await?;
        offset += elem8_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem9_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem9_len)?;
        let elem9 = T9::rematerialize(ctx, &data[offset..offset + elem9_len]).await?;
        offset += elem9_len;

        require_buffer_size(data, offset)?;
        Ok((
            elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7, elem8, elem9,
        ))
    }
}

// 11-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ContextTransmaterializable
    for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
    T4: ContextTransmaterializable + Send + Sync + 'static,
    T5: ContextTransmaterializable + Send + Sync + 'static,
    T6: ContextTransmaterializable + Send + Sync + 'static,
    T7: ContextTransmaterializable + Send + Sync + 'static,
    T8: ContextTransmaterializable + Send + Sync + 'static,
    T9: ContextTransmaterializable + Send + Sync + 'static,
    T10: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        // Elements 0-10
        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.immaterialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.immaterialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.immaterialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.immaterialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        let elem8_bytes = self.8.immaterialize(ctx).await?;
        let elem8_len = elem8_bytes.len() as u64;
        buffer.extend_from_slice(&elem8_len.to_le_bytes());
        buffer.extend_from_slice(&elem8_bytes);

        let elem9_bytes = self.9.immaterialize(ctx).await?;
        let elem9_len = elem9_bytes.len() as u64;
        buffer.extend_from_slice(&elem9_len.to_le_bytes());
        buffer.extend_from_slice(&elem9_bytes);

        let elem10_bytes = self.10.immaterialize(ctx).await?;
        let elem10_len = elem10_bytes.len() as u64;
        buffer.extend_from_slice(&elem10_len.to_le_bytes());
        buffer.extend_from_slice(&elem10_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        // Deserialize elements 0-10
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::rematerialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::rematerialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::rematerialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::rematerialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem8_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem8_len)?;
        let elem8 = T8::rematerialize(ctx, &data[offset..offset + elem8_len]).await?;
        offset += elem8_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem9_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem9_len)?;
        let elem9 = T9::rematerialize(ctx, &data[offset..offset + elem9_len]).await?;
        offset += elem9_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem10_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem10_len)?;
        let elem10 = T10::rematerialize(ctx, &data[offset..offset + elem10_len]).await?;
        offset += elem10_len;

        require_buffer_size(data, offset)?;
        Ok((
            elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7, elem8, elem9, elem10,
        ))
    }
}

// 12-tuple
#[async_trait]
impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ContextTransmaterializable
    for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
where
    T0: ContextTransmaterializable + Send + Sync + 'static,
    T1: ContextTransmaterializable + Send + Sync + 'static,
    T2: ContextTransmaterializable + Send + Sync + 'static,
    T3: ContextTransmaterializable + Send + Sync + 'static,
    T4: ContextTransmaterializable + Send + Sync + 'static,
    T5: ContextTransmaterializable + Send + Sync + 'static,
    T6: ContextTransmaterializable + Send + Sync + 'static,
    T7: ContextTransmaterializable + Send + Sync + 'static,
    T8: ContextTransmaterializable + Send + Sync + 'static,
    T9: ContextTransmaterializable + Send + Sync + 'static,
    T10: ContextTransmaterializable + Send + Sync + 'static,
    T11: ContextTransmaterializable + Send + Sync + 'static,
{
    async fn immaterialize(
        self,
        ctx: &TransmaterializationContext,
    ) -> TransmaterializationResult<Vec<u8>> {
        let mut buffer = Vec::new();

        // Elements 0-11
        let elem0_bytes = self.0.immaterialize(ctx).await?;
        let elem0_len = elem0_bytes.len() as u64;
        buffer.extend_from_slice(&elem0_len.to_le_bytes());
        buffer.extend_from_slice(&elem0_bytes);

        let elem1_bytes = self.1.immaterialize(ctx).await?;
        let elem1_len = elem1_bytes.len() as u64;
        buffer.extend_from_slice(&elem1_len.to_le_bytes());
        buffer.extend_from_slice(&elem1_bytes);

        let elem2_bytes = self.2.immaterialize(ctx).await?;
        let elem2_len = elem2_bytes.len() as u64;
        buffer.extend_from_slice(&elem2_len.to_le_bytes());
        buffer.extend_from_slice(&elem2_bytes);

        let elem3_bytes = self.3.immaterialize(ctx).await?;
        let elem3_len = elem3_bytes.len() as u64;
        buffer.extend_from_slice(&elem3_len.to_le_bytes());
        buffer.extend_from_slice(&elem3_bytes);

        let elem4_bytes = self.4.immaterialize(ctx).await?;
        let elem4_len = elem4_bytes.len() as u64;
        buffer.extend_from_slice(&elem4_len.to_le_bytes());
        buffer.extend_from_slice(&elem4_bytes);

        let elem5_bytes = self.5.immaterialize(ctx).await?;
        let elem5_len = elem5_bytes.len() as u64;
        buffer.extend_from_slice(&elem5_len.to_le_bytes());
        buffer.extend_from_slice(&elem5_bytes);

        let elem6_bytes = self.6.immaterialize(ctx).await?;
        let elem6_len = elem6_bytes.len() as u64;
        buffer.extend_from_slice(&elem6_len.to_le_bytes());
        buffer.extend_from_slice(&elem6_bytes);

        let elem7_bytes = self.7.immaterialize(ctx).await?;
        let elem7_len = elem7_bytes.len() as u64;
        buffer.extend_from_slice(&elem7_len.to_le_bytes());
        buffer.extend_from_slice(&elem7_bytes);

        let elem8_bytes = self.8.immaterialize(ctx).await?;
        let elem8_len = elem8_bytes.len() as u64;
        buffer.extend_from_slice(&elem8_len.to_le_bytes());
        buffer.extend_from_slice(&elem8_bytes);

        let elem9_bytes = self.9.immaterialize(ctx).await?;
        let elem9_len = elem9_bytes.len() as u64;
        buffer.extend_from_slice(&elem9_len.to_le_bytes());
        buffer.extend_from_slice(&elem9_bytes);

        let elem10_bytes = self.10.immaterialize(ctx).await?;
        let elem10_len = elem10_bytes.len() as u64;
        buffer.extend_from_slice(&elem10_len.to_le_bytes());
        buffer.extend_from_slice(&elem10_bytes);

        let elem11_bytes = self.11.immaterialize(ctx).await?;
        let elem11_len = elem11_bytes.len() as u64;
        buffer.extend_from_slice(&elem11_len.to_le_bytes());
        buffer.extend_from_slice(&elem11_bytes);

        Ok(buffer)
    }

    async fn rematerialize(
        ctx: &TransmaterializationContext,
        data: &[u8],
    ) -> TransmaterializationResult<Self> {
        let mut offset = 0;

        // Deserialize elements 0-11
        require_min_buffer_size(data, offset + 8)?;
        let elem0_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem0_len)?;
        let elem0 = T0::rematerialize(ctx, &data[offset..offset + elem0_len]).await?;
        offset += elem0_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem1_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem1_len)?;
        let elem1 = T1::rematerialize(ctx, &data[offset..offset + elem1_len]).await?;
        offset += elem1_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem2_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem2_len)?;
        let elem2 = T2::rematerialize(ctx, &data[offset..offset + elem2_len]).await?;
        offset += elem2_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem3_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem3_len)?;
        let elem3 = T3::rematerialize(ctx, &data[offset..offset + elem3_len]).await?;
        offset += elem3_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem4_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem4_len)?;
        let elem4 = T4::rematerialize(ctx, &data[offset..offset + elem4_len]).await?;
        offset += elem4_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem5_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem5_len)?;
        let elem5 = T5::rematerialize(ctx, &data[offset..offset + elem5_len]).await?;
        offset += elem5_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem6_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem6_len)?;
        let elem6 = T6::rematerialize(ctx, &data[offset..offset + elem6_len]).await?;
        offset += elem6_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem7_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem7_len)?;
        let elem7 = T7::rematerialize(ctx, &data[offset..offset + elem7_len]).await?;
        offset += elem7_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem8_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem8_len)?;
        let elem8 = T8::rematerialize(ctx, &data[offset..offset + elem8_len]).await?;
        offset += elem8_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem9_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem9_len)?;
        let elem9 = T9::rematerialize(ctx, &data[offset..offset + elem9_len]).await?;
        offset += elem9_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem10_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem10_len)?;
        let elem10 = T10::rematerialize(ctx, &data[offset..offset + elem10_len]).await?;
        offset += elem10_len;

        require_min_buffer_size(data, offset + 8)?;
        let elem11_len = usize_from_u64_le_bytes(&data[offset..offset + 8])?;
        offset += 8;
        require_min_buffer_size(data, offset + elem11_len)?;
        let elem11 = T11::rematerialize(ctx, &data[offset..offset + elem11_len]).await?;
        offset += elem11_len;

        require_buffer_size(data, offset)?;
        Ok((
            elem0, elem1, elem2, elem3, elem4, elem5, elem6, elem7, elem8, elem9, elem10, elem11,
        ))
    }
}

//! Typed wrappers for ActorRef instantiations.
//!
//! Architecture:
//! - `Ffi{Actor}ActorLocal`: Local actor that receives messages via handler
//!   - `stop()`, `is_running()`: Common lifecycle methods
//!   - `to_ref()`: Convert to an ActorRef for sending
//!
//! - `Ffi{Actor}ActorRef`: Unified interface for sending messages
//!   - `send(msg)`: Send a message (works for both local and remote refs)
//!   - Same type returned by `local.to_ref()` and `connection.get_remote_*()`

use std::sync::{Arc, RwLock};

use ractor::ActorRef;

use crate::error::WormholeError;
use crate::ffi_core::WormholeRuntime;
use crate::ffi_messages::FfiChatClientMessage;
use crate::messages::{ChatClientMessage, ChatMessageContent, ChatServerMessage, HubMessage};

// =============================================================================
// ChatClient Actor
// =============================================================================

/// Reference to a ChatClient actor - used for sending messages.
///
/// This is the unified type for both:
/// - Local refs obtained via `FfiChatClientActorLocal.to_ref()`
/// - Remote refs obtained via `WormholeConnection.get_remote_chat_client_actor()`
#[derive(uniffi::Object)]
pub struct FfiChatClientActorRef {
    pub(crate) runtime: Arc<WormholeRuntime>,
    pub(crate) actor_ref: ActorRef<ChatClientMessage>,
}

#[uniffi::export]
impl FfiChatClientActorRef {
    /// Send a message to this actor.
    ///
    /// This is the uniform send interface - pass the FFI message enum.
    pub fn send(&self, msg: FfiChatClientMessage) -> Result<(), WormholeError> {
        let internal_msg: ChatClientMessage = msg.into();
        self.actor_ref
            .send_message(internal_msg)
            .map_err(|e| WormholeError::SendFailed {
                reason: e.to_string(),
            })
    }

    // Convenience methods that mirror the enum variants
    // These could be generated by proc macro from the enum definition

    /// Send UserConnected notification.
    pub fn send_user_connected(&self, alias: String) -> Result<(), WormholeError> {
        self.send(FfiChatClientMessage::UserConnected { alias })
    }

    /// Send UserDisconnected notification.
    pub fn send_user_disconnected(&self, alias: String) -> Result<(), WormholeError> {
        self.send(FfiChatClientMessage::UserDisconnected { alias })
    }

    /// Send MessageReceived notification.
    pub fn send_message(&self, sender: String, content: String) -> Result<(), WormholeError> {
        self.send(FfiChatClientMessage::MessageReceived { sender, content })
    }

    /// Send ServerShutdown notification.
    pub fn send_server_shutdown(&self) -> Result<(), WormholeError> {
        self.send(FfiChatClientMessage::ServerShutdown)
    }
}

/// Local ChatClient actor - receives notifications from the server.
///
/// Create with `WormholeRuntime.create_chat_client_actor(handler)`.
/// Messages are delivered via the handler's `receive` method.
#[derive(uniffi::Object)]
pub struct FfiChatClientActorLocal {
    pub(crate) runtime: Arc<WormholeRuntime>,
    pub(crate) actor_ref: RwLock<Option<ActorRef<ChatClientMessage>>>,
}

impl FfiChatClientActorLocal {
    pub(crate) fn get_actor_ref(&self) -> Option<ActorRef<ChatClientMessage>> {
        self.actor_ref.read().unwrap().clone()
    }
}

#[uniffi::export]
impl FfiChatClientActorLocal {
    /// Stop this actor.
    pub fn stop(&self) {
        if let Some(actor) = self.actor_ref.write().unwrap().take() {
            actor.stop(Some("Stopped by FFI".into()));
        }
    }

    /// Check if this actor is still running.
    pub fn is_running(&self) -> bool {
        self.actor_ref.read().unwrap().is_some()
    }

    /// Get a reference to this actor for sending messages.
    ///
    /// The returned ref can be used to send messages, just like remote refs.
    pub fn to_ref(&self) -> Result<Arc<FfiChatClientActorRef>, WormholeError> {
        let actor_ref = self
            .actor_ref
            .read()
            .unwrap()
            .clone()
            .ok_or(WormholeError::ActorStopped)?;

        Ok(Arc::new(FfiChatClientActorRef {
            runtime: self.runtime.clone(),
            actor_ref,
        }))
    }
}

// =============================================================================
// ChatServer Actor
// =============================================================================

/// Reference to a ChatServer actor - used for sending messages/requests.
#[derive(uniffi::Object)]
pub struct FfiChatServerActorRef {
    pub(crate) runtime: Arc<WormholeRuntime>,
    pub(crate) actor_ref: ActorRef<ChatServerMessage>,
}

#[uniffi::export]
impl FfiChatServerActorRef {
    /// Post a message to the chat server and wait for acknowledgment.
    ///
    /// This is a blocking RPC call.
    pub fn post_message(&self, content: String) -> Result<(), WormholeError> {
        use ractor_wormhole::util::ActorRef_Ask;

        self.runtime.block_on(async {
            self.actor_ref
                .ask(
                    |rpc| ChatServerMessage::PostMessage(ChatMessageContent(content), rpc),
                    None,
                )
                .await
                .map_err(|e| WormholeError::SendFailed {
                    reason: e.to_string(),
                })
        })
    }

    /// Request the list of connected users.
    ///
    /// This is a blocking RPC call.
    pub fn list_users(&self) -> Result<Vec<String>, WormholeError> {
        use ractor_wormhole::util::ActorRef_Ask;

        self.runtime.block_on(async {
            let users = self
                .actor_ref
                .ask(|rpc| ChatServerMessage::ListUsers(rpc), None)
                .await
                .map_err(|e| WormholeError::SendFailed {
                    reason: e.to_string(),
                })?;

            Ok(users.into_iter().map(|u| u.0).collect())
        })
    }
}

/// Local ChatServer actor - handles messages from clients.
#[derive(uniffi::Object)]
pub struct FfiChatServerActorLocal {
    pub(crate) runtime: Arc<WormholeRuntime>,
    pub(crate) actor_ref: RwLock<Option<ActorRef<ChatServerMessage>>>,
}

impl FfiChatServerActorLocal {
    pub(crate) fn get_actor_ref(&self) -> Option<ActorRef<ChatServerMessage>> {
        self.actor_ref.read().unwrap().clone()
    }
}

#[uniffi::export]
impl FfiChatServerActorLocal {
    /// Stop this actor.
    pub fn stop(&self) {
        if let Some(actor) = self.actor_ref.write().unwrap().take() {
            actor.stop(Some("Stopped by FFI".into()));
        }
    }

    /// Check if this actor is still running.
    pub fn is_running(&self) -> bool {
        self.actor_ref.read().unwrap().is_some()
    }

    /// Get a reference to this actor for sending messages.
    pub fn to_ref(&self) -> Result<Arc<FfiChatServerActorRef>, WormholeError> {
        let actor_ref = self
            .actor_ref
            .read()
            .unwrap()
            .clone()
            .ok_or(WormholeError::ActorStopped)?;

        Ok(Arc::new(FfiChatServerActorRef {
            runtime: self.runtime.clone(),
            actor_ref,
        }))
    }
}

// =============================================================================
// Hub Actor
// =============================================================================

/// Reference to a Hub actor - used for connecting to a server.
#[derive(uniffi::Object)]
pub struct FfiHubActorRef {
    pub(crate) runtime: Arc<WormholeRuntime>,
    pub(crate) actor_ref: ActorRef<HubMessage>,
}

/// Result of connecting to a hub.
#[derive(uniffi::Record)]
pub struct ConnectResult {
    /// The alias assigned to this client by the server.
    pub user_alias: String,
    /// Reference to the chat server actor for posting messages.
    pub server_actor: Arc<FfiChatServerActorRef>,
}

#[uniffi::export]
impl FfiHubActorRef {
    /// Connect to the hub with the given client actor.
    ///
    /// This sends a Connect request to the hub and waits for the response.
    /// The client_actor's ref is sent to the server so it can send notifications.
    pub fn connect(
        &self,
        client_actor: &Arc<FfiChatClientActorLocal>,
    ) -> Result<ConnectResult, WormholeError> {
        use ractor_wormhole::util::ActorRef_Ask;

        let client_ref = client_actor
            .get_actor_ref()
            .ok_or(WormholeError::ActorStopped)?;

        let runtime = self.runtime.clone();

        self.runtime.block_on(async {
            let (user_alias, server_ref) = self
                .actor_ref
                .ask(|rpc| HubMessage::Connect(client_ref, rpc), None)
                .await
                .map_err(|e| WormholeError::SendFailed {
                    reason: e.to_string(),
                })?;

            Ok(ConnectResult {
                user_alias: user_alias.0,
                server_actor: Arc::new(FfiChatServerActorRef {
                    runtime,
                    actor_ref: server_ref,
                }),
            })
        })
    }
}

/// Local Hub actor - the entry point for client connections.
#[derive(uniffi::Object)]
pub struct FfiHubActorLocal {
    pub(crate) runtime: Arc<WormholeRuntime>,
    pub(crate) actor_ref: RwLock<Option<ActorRef<HubMessage>>>,
}

impl FfiHubActorLocal {
    pub(crate) fn get_actor_ref(&self) -> Option<ActorRef<HubMessage>> {
        self.actor_ref.read().unwrap().clone()
    }
}

#[uniffi::export]
impl FfiHubActorLocal {
    /// Stop this actor.
    pub fn stop(&self) {
        if let Some(actor) = self.actor_ref.write().unwrap().take() {
            actor.stop(Some("Stopped by FFI".into()));
        }
    }

    /// Check if this actor is still running.
    pub fn is_running(&self) -> bool {
        self.actor_ref.read().unwrap().is_some()
    }

    /// Get a reference to this actor for sending messages.
    pub fn to_ref(&self) -> Result<Arc<FfiHubActorRef>, WormholeError> {
        let actor_ref = self
            .actor_ref
            .read()
            .unwrap()
            .clone()
            .ok_or(WormholeError::ActorStopped)?;

        Ok(Arc::new(FfiHubActorRef {
            runtime: self.runtime.clone(),
            actor_ref,
        }))
    }
}
